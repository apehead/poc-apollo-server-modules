"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errors_1 = require("./errors");
var types_1 = require("./types");
var utils_1 = require("./utils");
var Injector = /** @class */ (function () {
    function Injector(_name, _providerScope, _children) {
        if (_name === void 0) { _name = Date.now().toString(); }
        if (_providerScope === void 0) { _providerScope = types_1.ProviderScope.Application; }
        if (_children === void 0) { _children = new Set(); }
        this._name = _name;
        this._providerScope = _providerScope;
        this._children = _children;
        this._classMap = new Map();
        this._factoryMap = new Map();
        this._instanceMap = new Map();
        this._applicationScopeSet = new Set();
        this._requestScopeSet = new Set();
        this._sessionScopeSet = new Set();
    }
    Injector.prototype.addChild = function () {
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            children[_i] = arguments[_i];
        }
        var e_1, _a;
        try {
            for (var children_1 = tslib_1.__values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                var child = children_1_1.value;
                this._children.add(child);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Injector.prototype.removeChild = function () {
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            children[_i] = arguments[_i];
        }
        var e_2, _a;
        try {
            for (var children_2 = tslib_1.__values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
                var child = children_2_1.value;
                this._children.delete(child);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (children_2_1 && !children_2_1.done && (_a = children_2.return)) _a.call(children_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    Injector.prototype.hasChild = function (child) {
        return this._children.has(child);
    };
    Injector.prototype.provide = function (provider) {
        if (utils_1.isTypeProvider(provider)) {
            var options = Reflect.getMetadata(utils_1.PROVIDER_OPTIONS, provider);
            if (options && !options.overwrite && this.has(provider)) {
                throw new errors_1.ProviderAlreadyDefinedError(this._name, provider);
            }
            this._classMap.set(provider, provider);
            switch ((options && options.scope) || this._providerScope) {
                case types_1.ProviderScope.Application:
                    this._applicationScopeSet.add(provider);
                    break;
                case types_1.ProviderScope.Request:
                    this._requestScopeSet.add(provider);
                    break;
                case types_1.ProviderScope.Session:
                    this._sessionScopeSet.add(provider);
                    break;
            }
            return;
        }
        if (!provider.overwrite && this.has(provider.provide)) {
            throw new errors_1.ProviderAlreadyDefinedError(this._name, provider.provide);
        }
        if (utils_1.isValueProvider(provider)) {
            this._instanceMap.set(provider.provide, provider.useValue);
        }
        else if (utils_1.isClassProvider(provider)) {
            this._classMap.set(provider.provide, provider.useClass);
        }
        else if (utils_1.isFactoryProvider(provider)) {
            this._factoryMap.set(provider.provide, provider.useFactory);
        }
        else {
            throw new errors_1.ProviderNotValidError(this._name, provider['provide'] && provider);
        }
        switch (provider.scope || this._providerScope) {
            case types_1.ProviderScope.Application:
                this._applicationScopeSet.add(provider.provide);
                break;
            case types_1.ProviderScope.Request:
                this._requestScopeSet.add(provider.provide);
                break;
            case types_1.ProviderScope.Session:
                this._sessionScopeSet.add(provider.provide);
                break;
        }
    };
    Injector.prototype.has = function (serviceIdentifier) {
        return (this._instanceMap.has(serviceIdentifier) ||
            this._classMap.has(serviceIdentifier) ||
            this._factoryMap.has(serviceIdentifier));
    };
    Injector.prototype.remove = function (serviceIdentifier) {
        this._instanceMap.delete(serviceIdentifier);
        this._classMap.delete(serviceIdentifier);
        this._factoryMap.delete(serviceIdentifier);
    };
    Object.defineProperty(Injector.prototype, "scopeSet", {
        get: function () {
            switch (this._providerScope) {
                case types_1.ProviderScope.Application:
                    return this._applicationScopeSet;
                case types_1.ProviderScope.Request:
                    return this._requestScopeSet;
                case types_1.ProviderScope.Session:
                    return this._sessionScopeSet;
            }
        },
        enumerable: true,
        configurable: true
    });
    Injector.prototype.get = function (serviceIdentifier) {
        var _this = this;
        var e_3, _a, e_4, _b;
        if (this._instanceMap.has(serviceIdentifier)) {
            return this._instanceMap.get(serviceIdentifier);
        }
        else if (this._classMap.has(serviceIdentifier)) {
            var RealClazz = this._classMap.get(serviceIdentifier);
            try {
                var dependencies = Reflect.getMetadata(utils_1.DESIGN_PARAM_TYPES, RealClazz) || [];
                var dependencyInstances = dependencies.map(function (dependency) { return _this.get(dependency); });
                var instance = new (RealClazz.bind.apply(RealClazz, tslib_1.__spread([void 0], dependencyInstances)))();
                var propertyKeys = Reflect.getMetadata(utils_1.PROPERTY_KEYS, RealClazz.prototype) || [];
                try {
                    for (var propertyKeys_1 = tslib_1.__values(propertyKeys), propertyKeys_1_1 = propertyKeys_1.next(); !propertyKeys_1_1.done; propertyKeys_1_1 = propertyKeys_1.next()) {
                        var propertyKey = propertyKeys_1_1.value;
                        var dependency = Reflect.getMetadata(utils_1.DESIGN_TYPE, RealClazz.prototype, propertyKey);
                        if (dependency) {
                            Object.defineProperty(instance, propertyKey, {
                                value: this.get(dependency),
                            });
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (propertyKeys_1_1 && !propertyKeys_1_1.done && (_a = propertyKeys_1.return)) _a.call(propertyKeys_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                if (this.scopeSet.has(serviceIdentifier)) {
                    this._instanceMap.set(serviceIdentifier, instance);
                }
                return instance;
            }
            catch (e) {
                if (e instanceof errors_1.ServiceIdentifierNotFoundError) {
                    throw new errors_1.DependencyProviderNotFoundError(e.serviceIdentifier, RealClazz, this._name);
                }
                else {
                    throw e;
                }
            }
        }
        else if (this._factoryMap.has(serviceIdentifier)) {
            var factory = this._factoryMap.get(serviceIdentifier);
            var instance = this.call(factory, this);
            if (this.scopeSet.has(serviceIdentifier)) {
                this._instanceMap.set(serviceIdentifier, instance);
            }
            return instance;
        }
        else {
            try {
                for (var _c = tslib_1.__values(this._children), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var child = _d.value;
                    try {
                        return child.get(serviceIdentifier);
                    }
                    catch (e) {
                        if (e instanceof errors_1.ServiceIdentifierNotFoundError) {
                            continue;
                        }
                        else {
                            throw e;
                        }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
            throw new errors_1.ServiceIdentifierNotFoundError(serviceIdentifier, this._name);
        }
    };
    Injector.prototype.getSessionInjector = function (session) {
        var e_5, _a, e_6, _b;
        if (!Injector.sessionNameSessionInjectorMapMap.has(session)) {
            Injector.sessionNameSessionInjectorMapMap.set(session, new Map());
        }
        var nameSessionInjectorMap = Injector.sessionNameSessionInjectorMapMap.get(session);
        if (!nameSessionInjectorMap.has(this._name)) {
            var sessionInjector = new Injector(this._name + '_SESSION', types_1.ProviderScope.Session);
            try {
                for (var _c = tslib_1.__values(this._children), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var child = _d.value;
                    sessionInjector._children.add(child.getSessionInjector(session));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_5) throw e_5.error; }
            }
            try {
                for (var _e = tslib_1.__values(this._instanceMap), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var _g = tslib_1.__read(_f.value, 2), serviceIdentifier = _g[0], instance = _g[1];
                    sessionInjector._instanceMap.set(serviceIdentifier, instance);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_6) throw e_6.error; }
            }
            sessionInjector._classMap = this._classMap;
            sessionInjector._factoryMap = this._factoryMap;
            sessionInjector._applicationScopeSet = this._applicationScopeSet;
            sessionInjector._requestScopeSet = this._requestScopeSet;
            sessionInjector._sessionScopeSet = this._sessionScopeSet;
            nameSessionInjectorMap.set(this._name, sessionInjector);
        }
        return nameSessionInjectorMap.get(this._name);
    };
    Injector.prototype.call = function (fn, thisArg) {
        var _this = this;
        if ('hasMetadata' in Reflect && Reflect.hasMetadata(utils_1.DESIGN_PARAM_TYPES, fn)) {
            var dependencies = Reflect.getMetadata(utils_1.DESIGN_PARAM_TYPES, fn);
            var instances = dependencies.map(function (dependency) { return _this.get(dependency); });
            return fn.call.apply(fn, tslib_1.__spread([thisArg], instances));
        }
        return fn.call(thisArg, thisArg);
    };
    Injector.prototype.callHookWithArgs = function (hook, serviceIdentifier) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var instance;
            return tslib_1.__generator(this, function (_a) {
                instance = this.get(serviceIdentifier);
                if (instance &&
                    typeof instance !== 'string' &&
                    typeof instance !== 'number' &&
                    hook in instance) {
                    return [2 /*return*/, instance[hook].apply(instance, tslib_1.__spread(args))];
                }
                return [2 /*return*/];
            });
        });
    };
    Injector.sessionNameSessionInjectorMapMap = new WeakMap();
    return Injector;
}());
exports.Injector = Injector;
//# sourceMappingURL=injector.js.map