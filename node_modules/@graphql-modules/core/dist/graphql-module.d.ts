import { IResolvers, SchemaDirectiveVisitor, ILogger, IDirectiveResolvers, IResolverValidationOptions } from 'graphql-tools';
import { Provider, Injector } from '@graphql-modules/di';
import { DocumentNode, GraphQLSchema } from 'graphql';
import { IResolversComposerMapping } from './resolvers-composition';
import { ModuleSessionInfo } from './module-session-info';
import { ModuleContext, ISubscriptionHooks } from './types';
/**
 * A context builder method signature for `contextBuilder`.
 */
export declare type BuildContextFn<Config, Session, Context> = (session: Session, currentContext: ModuleContext<any>, moduleSessionInfo: ModuleSessionInfo<Config, Session, Context>) => Promise<Context> | Context;
export interface ISchemaDirectives {
    [name: string]: typeof SchemaDirectiveVisitor;
}
export declare type ModulesMap<Session> = Map<string, GraphQLModule<any, Session, any>>;
/**
 * Defines the structure of a dependency as it declared in each module's `dependencies` field.
 */
export declare type ModuleDependency<Config, Session, Context> = GraphQLModule<Config, Session, Context> | string;
export declare type GraphQLModuleOption<Option, Config, Session, Context> = Option | ((module: GraphQLModule<Config, Session, Context>, ...args: any[]) => Option);
export declare type GraphQLModuleMiddleware<Session, Context> = (moduleCache: ModuleCache<Session, Context>) => Partial<ModuleCache<Session, Context>> | void;
export interface KeyValueCache {
    get(key: string): Promise<string | undefined>;
    set(key: string, value: string, options?: {
        ttl?: number;
    }): Promise<void>;
    delete(key: string): Promise<boolean | void>;
}
/**
 * Defined the structure of GraphQL module options object.
 */
export interface GraphQLModuleOptions<Config, Session, Context> {
    /**
     * The name of the module. Use it later to get your `ModuleConfig(name)` or to declare
     * a dependency to this module (in another module)
     */
    name?: string;
    /**
     * A definition of GraphQL type definitions, as string or `DocumentNode`.
     * Arrays are also accepted, and they will get merged.
     * You can also pass a function that will get the module's config as argument, and should return
     * the type definitions.
     */
    typeDefs?: GraphQLModuleOption<string | string[] | DocumentNode | DocumentNode[], Config, Session, Context>;
    /**
     * Resolvers object, or a function will get the module's config as argument, and should
     * return the resolvers object.
     */
    resolvers?: GraphQLModuleOption<IResolvers<any, ModuleContext<Context>>, Config, Session, Context>;
    /**
     * Context builder method. Use this to add your own fields and data to the GraphQL `context`
     * of each execution of GraphQL.
     */
    context?: BuildContextFn<Config, Session, Context> | Promise<Context> | Context;
    /**
     * The dependencies that this module need to run correctly, you can either provide the `GraphQLModule`,
     * or provide a string with the name of the other module.
     * Adding a dependency will effect the order of the type definition building, resolvers building and context
     * building.
     */
    imports?: GraphQLModuleOption<Array<ModuleDependency<any, any, any>>, Config, Session, Context>;
    /**
     * A list of `Providers` to load into the GraphQL module.
     * It could be either a `class` or a value/class instance.
     * All loaded class will be loaded as Singletons, and the instance will be
     * shared across all GraphQL executions.
     */
    providers?: GraphQLModuleOption<Provider[], Config, Session, Context>;
    /** Object map between `Type.field` to a function(s) that will wrap the resolver of the field  */
    resolversComposition?: GraphQLModuleOption<IResolversComposerMapping, Config, Session, Context>;
    schemaDirectives?: GraphQLModuleOption<ISchemaDirectives, Config, Session, Context>;
    directiveResolvers?: GraphQLModuleOption<IDirectiveResolvers, Config, Session, Context>;
    logger?: GraphQLModuleOption<ILogger, Config, Session, Context>;
    extraSchemas?: GraphQLModuleOption<GraphQLSchema[], Config, Session, Context>;
    middleware?: GraphQLModuleMiddleware<Session, Context>;
    cache?: KeyValueCache;
    mergeCircularImports?: boolean;
    warnCircularImports?: boolean;
    configRequired?: boolean;
    resolverValidationOptions?: GraphQLModuleOption<IResolverValidationOptions, Config, Session, Context>;
}
/**
 * Returns a dependency injection token for getting a module's configuration object by
 * the module's name.
 * You can use this later with `@Inject` in your `Provider`s.
 *
 * @param module
 * @constructor
 */
export declare const ModuleConfig: (module: ModuleDependency<any, any, any>) => symbol;
export interface ModuleCache<Session, Context> {
    injector: Injector;
    schema: GraphQLSchema;
    typeDefs: DocumentNode;
    resolvers: IResolvers<any, ModuleContext<Context>>;
    schemaDirectives: ISchemaDirectives;
    contextBuilder: (session: Session, excludeSession?: boolean) => Promise<Context>;
    modulesMap: ModulesMap<Session>;
    extraSchemas: GraphQLSchema[];
    directiveResolvers: IDirectiveResolvers;
    subscriptionHooks: ISubscriptionHooks;
}
/**
 * Represents a GraphQL module that has it's own types, resolvers, context and business logic.
 * You can read more about it in the Documentation section. {@link /docs/introduction/modules}
 *
 * You can also specific `Config` generic to tell TypeScript what's the structure of your
 * configuration object to use later with `forRoot`
 */
export declare class GraphQLModule<Config = any, Session = any, Context = any> {
    private _options;
    private _moduleConfig?;
    private _cache;
    /**
     * Creates a new `GraphQLModule` instance, merged it's type definitions and resolvers.
     * @param options - module configuration
     */
    constructor(_options?: GraphQLModuleOptions<Config, Session, Context>, _moduleConfig?: Config);
    /**
     * Creates another instance of the module using a configuration
     * @param config - the config object
     */
    forRoot(config: Config): GraphQLModule<Config, Session, Context>;
    forChild(): string;
    readonly name: string;
    readonly config: Config;
    /**
     * Gets the application `GraphQLSchema` object.
     * If the schema object is not built yet, it compiles
     * the `typeDefs` and `resolvers` into `GraphQLSchema`
     */
    readonly schema: GraphQLSchema;
    /**
     * Gets the application dependency-injection injector
     */
    readonly injector: Injector;
    readonly cache: KeyValueCache;
    /**
     * Gets the merged GraphQL type definitions as one string
     */
    readonly typeDefs: DocumentNode;
    readonly resolvers: IResolvers<any, ModuleContext<Context>>;
    readonly schemaDirectives: ISchemaDirectives;
    readonly subscriptions: ISubscriptionHooks;
    readonly selfExtraSchemas: GraphQLSchema[];
    /**
     * Returns the GraphQL type definitions of the module
     * @return a `string` with the merged type definitions
     */
    readonly selfTypeDefs: DocumentNode;
    readonly selfResolvers: IResolvers<any, ModuleContext<Context>>;
    readonly selfImports: ModuleDependency<any, any, any>[];
    readonly selfProviders: Provider[];
    readonly selfResolversComposition: IResolversComposerMapping;
    readonly selfSchemaDirectives: ISchemaDirectives;
    readonly selfDirectiveResolvers: IDirectiveResolvers;
    private checkIfResolverCalledSafely;
    private addSessionInjectorToSelfResolversContext;
    private addSessionInjectorToSelfResolversCompositionContext;
    readonly selfLogger: ILogger;
    readonly selfResolverValidationOptions: IResolverValidationOptions;
    private buildSchemaAndInjector;
    private static sessionModuleNameContextMap;
    getModuleNameContextMap(session: Session): Map<string, any>;
    /**
     * Build a GraphQL `context` object based on a network session.
     * It iterates over all modules by their dependency-based order, and executes
     * `contextBuilder` method.
     * It also in charge of injecting a reference to the application `Injector` to
     * the `context`.
     * The network session is passed to each `contextBuilder` method, and the return
     * value of each `contextBuilder` is merged into a unified `context` object.
     *
     * This method should be in use with your GraphQL manager, such as Apollo-Server.
     *
     * @param session - the network session from `connect`, `express`, etc...
     */
    readonly context: (session: Session, excludeSession?: boolean) => Promise<ModuleContext<Context>>;
    readonly modulesMap: Map<string, GraphQLModule<any, Session, any>>;
    private createInitialModulesMap;
    private checkAndFixModulesMap;
    static mergeModules<Config = any, Session = any, Context = any>(modules: Array<GraphQLModule<any, any, any>>, warnCircularImports?: boolean, modulesMap?: ModulesMap<Session>): GraphQLModule<Config, Session, Context>;
}
