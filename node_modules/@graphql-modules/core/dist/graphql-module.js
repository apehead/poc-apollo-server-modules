"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_tools_1 = require("graphql-tools");
var epoxy_1 = require("@graphql-modules/epoxy");
var di_1 = require("@graphql-modules/di");
var graphql_1 = require("graphql");
var resolvers_composition_1 = require("./resolvers-composition");
var dependency_graph_1 = require("dependency-graph");
var errors_1 = require("./errors");
var deepmerge = require("deepmerge");
var module_session_info_1 = require("./module-session-info");
var utils_1 = require("./utils");
/**
 * Returns a dependency injection token for getting a module's configuration object by
 * the module's name.
 * You can use this later with `@Inject` in your `Provider`s.
 *
 * @param module
 * @constructor
 */
exports.ModuleConfig = function (module) {
    return Symbol.for("ModuleConfig." + (typeof module === 'string' ? module : module.name));
};
/**
 * Represents a GraphQL module that has it's own types, resolvers, context and business logic.
 * You can read more about it in the Documentation section. {@link /docs/introduction/modules}
 *
 * You can also specific `Config` generic to tell TypeScript what's the structure of your
 * configuration object to use later with `forRoot`
 */
var GraphQLModule = /** @class */ (function () {
    /**
     * Creates a new `GraphQLModule` instance, merged it's type definitions and resolvers.
     * @param options - module configuration
     */
    function GraphQLModule(_options, _moduleConfig) {
        if (_options === void 0) { _options = {}; }
        var _this = this;
        this._options = _options;
        this._moduleConfig = _moduleConfig;
        this._cache = {
            injector: undefined,
            schema: undefined,
            typeDefs: undefined,
            resolvers: undefined,
            schemaDirectives: undefined,
            contextBuilder: undefined,
            modulesMap: undefined,
            extraSchemas: undefined,
            directiveResolvers: undefined,
            subscriptionHooks: undefined,
        };
        _options.name = _options.name || Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER)).toString();
        if (!('mergeCircularImports' in _options)) {
            _options.mergeCircularImports = true;
        }
        if (!('warnCircularImports' in _options)) {
            _options.warnCircularImports = true;
        }
        if (!('logger' in _options)) {
            _options.logger = {
                log: function () { },
            };
        }
        if (!('cache' in _options)) {
            var storage_1 = new Map();
            _options.cache = {
                get: function (key) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, storage_1.get(key)];
                }); }); },
                set: function (key, value) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    storage_1.set(key, value);
                    return [2 /*return*/];
                }); }); },
                delete: function (key) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, storage_1.delete(key)];
                }); }); },
            };
        }
    }
    /**
     * Creates another instance of the module using a configuration
     * @param config - the config object
     */
    GraphQLModule.prototype.forRoot = function (config) {
        return new GraphQLModule(this._options, config);
    };
    GraphQLModule.prototype.forChild = function () {
        return this.name;
    };
    Object.defineProperty(GraphQLModule.prototype, "name", {
        get: function () {
            return this._options.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "config", {
        get: function () {
            return this._moduleConfig;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "schema", {
        /**
         * Gets the application `GraphQLSchema` object.
         * If the schema object is not built yet, it compiles
         * the `typeDefs` and `resolvers` into `GraphQLSchema`
         */
        get: function () {
            if (this._options.configRequired && !this._moduleConfig) {
                throw new errors_1.ModuleConfigRequiredError(this.name);
            }
            if (typeof this._cache.schema === 'undefined') {
                this.buildSchemaAndInjector();
            }
            return this._cache.schema;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "injector", {
        /**
         * Gets the application dependency-injection injector
         */
        get: function () {
            if (this._options.configRequired && !this._moduleConfig) {
                throw new errors_1.ModuleConfigRequiredError(this.name);
            }
            if (typeof this._cache.injector === 'undefined') {
                this.buildSchemaAndInjector();
            }
            return this._cache.injector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "cache", {
        get: function () {
            return this._options.cache;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "typeDefs", {
        /**
         * Gets the merged GraphQL type definitions as one string
         */
        get: function () {
            var e_1, _a;
            if (typeof this._cache.typeDefs === 'undefined') {
                var modulesMap = this.modulesMap;
                var typeDefsSet = new Set();
                var selfImports = this.selfImports;
                try {
                    for (var selfImports_1 = tslib_1.__values(selfImports), selfImports_1_1 = selfImports_1.next(); !selfImports_1_1.done; selfImports_1_1 = selfImports_1.next()) {
                        var module_1 = selfImports_1_1.value;
                        var moduleName = typeof module_1 === 'string' ? module_1 : module_1.name;
                        module_1 = modulesMap.get(moduleName);
                        if (module_1._cache.modulesMap !== modulesMap) {
                            module_1._cache.modulesMap = modulesMap;
                            module_1._cache.typeDefs = undefined;
                        }
                        var moduleTypeDefs = module_1.typeDefs;
                        if (moduleTypeDefs) {
                            typeDefsSet.add(moduleTypeDefs);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (selfImports_1_1 && !selfImports_1_1.done && (_a = selfImports_1.return)) _a.call(selfImports_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                var selfTypeDefs = this.selfTypeDefs;
                if (selfTypeDefs) {
                    typeDefsSet.add(selfTypeDefs);
                }
                this._cache.typeDefs = epoxy_1.mergeGraphQLSchemas(tslib_1.__spread(typeDefsSet), {
                    useSchemaDefinition: false,
                });
            }
            return this._cache.typeDefs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "resolvers", {
        get: function () {
            if (typeof this._cache.resolvers === 'undefined') {
                this.buildSchemaAndInjector();
            }
            return this._cache.resolvers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "schemaDirectives", {
        get: function () {
            if (typeof this._cache.schemaDirectives === 'undefined') {
                this.buildSchemaAndInjector();
            }
            return this._cache.schemaDirectives;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "subscriptions", {
        get: function () {
            if (typeof this._cache.subscriptionHooks === 'undefined') {
                this.buildSchemaAndInjector();
            }
            return this._cache.subscriptionHooks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfExtraSchemas", {
        get: function () {
            var extraSchemas = new Array();
            var extraSchemasDefinitions = this._options.extraSchemas;
            if (extraSchemasDefinitions) {
                if (typeof extraSchemasDefinitions === 'function') {
                    extraSchemas = extraSchemasDefinitions(this);
                }
                else {
                    extraSchemas = extraSchemasDefinitions;
                }
            }
            return extraSchemas;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfTypeDefs", {
        /**
         * Returns the GraphQL type definitions of the module
         * @return a `string` with the merged type definitions
         */
        get: function () {
            var typeDefs = null;
            var typeDefsDefinitions = this._options.typeDefs;
            if (typeDefsDefinitions) {
                if (typeof typeDefsDefinitions === 'function') {
                    typeDefsDefinitions = typeDefsDefinitions(this);
                }
                if (typeof typeDefsDefinitions === 'string') {
                    typeDefs = graphql_1.parse(typeDefsDefinitions);
                }
                else if (Array.isArray(typeDefsDefinitions)) {
                    typeDefs = epoxy_1.mergeGraphQLSchemas(typeDefsDefinitions, {
                        useSchemaDefinition: false,
                    });
                }
                else if (typeDefsDefinitions) {
                    typeDefs = typeDefsDefinitions;
                }
            }
            return typeDefs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfResolvers", {
        get: function () {
            var resolvers = {};
            var resolversDefinitions = this._options.resolvers;
            if (resolversDefinitions) {
                if (typeof resolversDefinitions === 'function') {
                    resolvers = this.injector.call(resolversDefinitions, this);
                }
                else {
                    resolvers = resolversDefinitions;
                }
            }
            return resolvers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfImports", {
        get: function () {
            var imports = new Array();
            if (this._options.imports) {
                if (typeof this._options.imports === 'function') {
                    imports = this._options.imports(this);
                }
                else {
                    imports = this._options.imports;
                }
            }
            return imports;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfProviders", {
        get: function () {
            var providers = new Array();
            var providersDefinitions = this._options.providers;
            if (providersDefinitions) {
                if (typeof providersDefinitions === 'function') {
                    providers = providersDefinitions(this);
                }
                else {
                    providers = providersDefinitions;
                }
            }
            return tslib_1.__spread([
                {
                    provide: exports.ModuleConfig(this),
                    useValue: this.config,
                }
            ], providers);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfResolversComposition", {
        get: function () {
            var resolversComposition = {};
            var resolversCompositionDefinitions = this._options.resolversComposition;
            if (resolversCompositionDefinitions) {
                if (resolversCompositionDefinitions instanceof Function) {
                    resolversComposition = this.injector.call(resolversCompositionDefinitions, this);
                }
                else {
                    resolversComposition = resolversCompositionDefinitions;
                }
            }
            return resolversComposition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfSchemaDirectives", {
        get: function () {
            var schemaDirectives = {};
            var schemaDirectivesDefinitions = this._options.schemaDirectives;
            if (schemaDirectivesDefinitions) {
                if (typeof schemaDirectivesDefinitions === 'function') {
                    schemaDirectives = this.injector.call(schemaDirectivesDefinitions, this);
                }
                else {
                    schemaDirectives = schemaDirectivesDefinitions;
                }
            }
            return schemaDirectives;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfDirectiveResolvers", {
        get: function () {
            var directiveResolvers = {};
            var directiveResolversDefinitions = this._options.directiveResolvers;
            if (directiveResolversDefinitions) {
                if (typeof directiveResolversDefinitions === 'function') {
                    directiveResolvers = this.injector.call(directiveResolversDefinitions, this);
                }
                else {
                    directiveResolvers = directiveResolversDefinitions;
                }
            }
            return directiveResolvers;
        },
        enumerable: true,
        configurable: true
    });
    GraphQLModule.prototype.checkIfResolverCalledSafely = function (resolverPath, session, info) {
        if (typeof session === 'undefined') {
            throw new errors_1.IllegalResolverInvocationError(resolverPath, this.name, "Network Session hasn't been passed!");
        }
        if (typeof info === 'undefined') {
            throw new errors_1.IllegalResolverInvocationError(resolverPath, this.name, "GraphQL Resolve Information hasn't been passed!");
        }
    };
    GraphQLModule.prototype.addSessionInjectorToSelfResolversContext = function () {
        var _this = this;
        var resolvers = this.selfResolvers;
        var _loop_1 = function (type) {
            var typeResolvers = resolvers[type];
            if (!(typeResolvers instanceof graphql_1.GraphQLScalarType)) {
                var _loop_2 = function (prop) {
                    var resolver = typeResolvers[prop];
                    if (typeof resolver === 'function') {
                        if (prop !== '__resolveType') {
                            typeResolvers[prop] = function (root, args, appContext, info) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var session, moduleContext, e_2;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            session = info.session || appContext.session;
                                            info.session = session;
                                            this.checkIfResolverCalledSafely(type + "." + prop, session, info);
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, this.context(session, true)];
                                        case 2:
                                            moduleContext = _a.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            e_2 = _a.sent();
                                            console.error(e_2);
                                            throw e_2;
                                        case 4:
                                            info.schema = this.schema;
                                            return [2 /*return*/, resolver.call(typeResolvers[prop], root, args, moduleContext, info)];
                                    }
                                });
                            }); };
                        }
                        else {
                            typeResolvers[prop] = function (root, appContext, info) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var session, moduleContext, e_3;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            session = info.session || appContext.session;
                                            info.session = session;
                                            this.checkIfResolverCalledSafely(type + "." + prop, session, info);
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, this.context(session, true)];
                                        case 2:
                                            moduleContext = _a.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            e_3 = _a.sent();
                                            console.error(e_3);
                                            throw e_3;
                                        case 4:
                                            info.schema = this.schema;
                                            return [2 /*return*/, resolver.call(typeResolvers, root, moduleContext, info)];
                                    }
                                });
                            }); };
                        }
                    }
                    else if ('subscribe' in resolver) {
                        var subscriber_1 = resolver['subscribe'];
                        typeResolvers[prop]['subscribe'] = function (root, args, appContext, info) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var session, moduleContext, e_4;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        session = info.session || appContext.session;
                                        info.session = session;
                                        this.checkIfResolverCalledSafely(type + "." + prop, session, info);
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, this.context(session, true)];
                                    case 2:
                                        moduleContext = _a.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        e_4 = _a.sent();
                                        console.error(e_4);
                                        throw e_4;
                                    case 4:
                                        info.schema = this.schema;
                                        return [2 /*return*/, subscriber_1.call(typeResolvers[prop], root, args, moduleContext, info)];
                                }
                            });
                        }); };
                    }
                };
                // tslint:disable-next-line:forin
                for (var prop in resolvers[type]) {
                    _loop_2(prop);
                }
            }
        };
        // tslint:disable-next-line:forin
        for (var type in resolvers) {
            _loop_1(type);
        }
        return resolvers;
    };
    GraphQLModule.prototype.addSessionInjectorToSelfResolversCompositionContext = function () {
        var _this = this;
        var resolversComposition = this.selfResolversComposition;
        var _loop_3 = function (path) {
            var compositionArr = utils_1.asArray(resolversComposition[path]);
            resolversComposition[path] = tslib_1.__spread([
                function (next) { return function (root, args, appContext, info) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    var session, moduleContext, e_5;
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                session = info.session || appContext.session;
                                info.session = session;
                                this.checkIfResolverCalledSafely(path, session, info);
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                return [4 /*yield*/, this.context(session, true)];
                            case 2:
                                moduleContext = _a.sent();
                                return [3 /*break*/, 4];
                            case 3:
                                e_5 = _a.sent();
                                console.error(e_5);
                                throw e_5;
                            case 4:
                                info.schema = this.schema;
                                return [2 /*return*/, next(root, args, moduleContext, info)];
                        }
                    });
                }); }; }
            ], compositionArr);
        };
        // tslint:disable-next-line:forin
        for (var path in resolversComposition) {
            _loop_3(path);
        }
        return resolversComposition;
    };
    Object.defineProperty(GraphQLModule.prototype, "selfLogger", {
        get: function () {
            var logger;
            var loggerDefinitions = this._options.logger;
            if (loggerDefinitions) {
                if (logger instanceof Function) {
                    logger = this.injector.call(loggerDefinitions, this);
                }
                else {
                    logger = loggerDefinitions;
                }
            }
            return logger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "selfResolverValidationOptions", {
        get: function () {
            var resolverValidationOptions = {};
            var resolverValidationOptionsDefinitions = this._options.resolverValidationOptions;
            if (resolverValidationOptionsDefinitions) {
                if (resolverValidationOptionsDefinitions instanceof Function) {
                    resolverValidationOptions = this.injector.call(resolverValidationOptionsDefinitions, this);
                }
                else {
                    resolverValidationOptions = resolverValidationOptionsDefinitions;
                }
            }
            return resolverValidationOptions;
        },
        enumerable: true,
        configurable: true
    });
    GraphQLModule.prototype.buildSchemaAndInjector = function () {
        var _this = this;
        var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;
        var modulesMap = this.modulesMap;
        var imports = this.selfImports;
        var importsTypeDefs = new Set();
        var importsResolvers = new Set();
        var importsInjectors = new Set();
        var importsContextBuilders = new Set();
        var importsSchemaDirectives = new Set();
        var importsExtraSchemas = new Set();
        var importsDirectiveResolvers = new Set();
        var importsSubscriptionHooks = new Set();
        try {
            for (var imports_1 = tslib_1.__values(imports), imports_1_1 = imports_1.next(); !imports_1_1.done; imports_1_1 = imports_1.next()) {
                var module_2 = imports_1_1.value;
                var moduleName = typeof module_2 === 'string' ? module_2 : module_2.name;
                module_2 = modulesMap.get(moduleName);
                if (module_2._cache.modulesMap !== modulesMap) {
                    module_2._cache = {
                        injector: undefined,
                        schema: undefined,
                        typeDefs: undefined,
                        resolvers: undefined,
                        schemaDirectives: undefined,
                        contextBuilder: undefined,
                        modulesMap: modulesMap,
                        extraSchemas: undefined,
                        directiveResolvers: undefined,
                        subscriptionHooks: undefined,
                    };
                }
                var injector_1 = module_2.injector, resolvers_1 = module_2.resolvers, typeDefs = module_2.typeDefs, schemaDirectives = module_2.schemaDirectives;
                var _f = module_2._cache, contextBuilder = _f.contextBuilder, extraSchemas_3 = _f.extraSchemas, directiveResolvers = _f.directiveResolvers, subscriptionHooks = _f.subscriptionHooks;
                importsInjectors.add(injector_1);
                importsResolvers.add(resolvers_1);
                if (typeDefs) {
                    importsTypeDefs.add(typeDefs);
                }
                importsContextBuilders.add(contextBuilder);
                importsSchemaDirectives.add(schemaDirectives);
                try {
                    for (var extraSchemas_1 = tslib_1.__values(extraSchemas_3), extraSchemas_1_1 = extraSchemas_1.next(); !extraSchemas_1_1.done; extraSchemas_1_1 = extraSchemas_1.next()) {
                        var extraSchema = extraSchemas_1_1.value;
                        importsExtraSchemas.add(extraSchema);
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (extraSchemas_1_1 && !extraSchemas_1_1.done && (_b = extraSchemas_1.return)) _b.call(extraSchemas_1);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                importsDirectiveResolvers.add(directiveResolvers);
                if (subscriptionHooks) {
                    importsSubscriptionHooks.add(subscriptionHooks);
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (imports_1_1 && !imports_1_1.done && (_a = imports_1.return)) _a.call(imports_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        var injector = this._cache.injector = new di_1.Injector(this.name, di_1.ProviderScope.Application, importsInjectors);
        injector.provide({
            provide: GraphQLModule,
            useValue: this,
        });
        var providers = this.selfProviders;
        try {
            for (var providers_1 = tslib_1.__values(providers), providers_1_1 = providers_1.next(); !providers_1_1.done; providers_1_1 = providers_1.next()) {
                var provider = providers_1_1.value;
                injector.provide(provider);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (providers_1_1 && !providers_1_1.done && (_c = providers_1.return)) _c.call(providers_1);
            }
            finally { if (e_8) throw e_8.error; }
        }
        try {
            for (var _g = tslib_1.__values(injector.scopeSet), _h = _g.next(); !_h.done; _h = _g.next()) {
                var serviceIdentifier = _h.value;
                injector.get(serviceIdentifier);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
            }
            finally { if (e_9) throw e_9.error; }
        }
        var resolvers = this.addSessionInjectorToSelfResolversContext();
        var resolversComposition = this.addSessionInjectorToSelfResolversCompositionContext();
        var resolversToBeComposed = new Set(importsResolvers);
        resolversToBeComposed.add(resolvers);
        var composedResolvers = resolvers_composition_1.composeResolvers(epoxy_1.mergeResolvers(tslib_1.__spread(resolversToBeComposed)), resolversComposition);
        this._cache.resolvers = composedResolvers;
        var typeDefsToBeMerged = new Set(importsTypeDefs);
        var selfTypeDefs = this.selfTypeDefs;
        if (selfTypeDefs) {
            typeDefsToBeMerged.add(selfTypeDefs);
        }
        var schemaDirectivesToBeMerged = new Set(importsSchemaDirectives);
        schemaDirectivesToBeMerged.add(this.selfSchemaDirectives);
        var mergedSchemaDirectives = deepmerge.all(tslib_1.__spread(schemaDirectivesToBeMerged));
        this._cache.schemaDirectives = mergedSchemaDirectives;
        var extraSchemas = this.selfExtraSchemas;
        var allExtraSchemas = new Set(importsExtraSchemas);
        try {
            for (var extraSchemas_2 = tslib_1.__values(extraSchemas), extraSchemas_2_1 = extraSchemas_2.next(); !extraSchemas_2_1.done; extraSchemas_2_1 = extraSchemas_2.next()) {
                var extraSchema = extraSchemas_2_1.value;
                allExtraSchemas.add(extraSchema);
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (extraSchemas_2_1 && !extraSchemas_2_1.done && (_e = extraSchemas_2.return)) _e.call(extraSchemas_2);
            }
            finally { if (e_10) throw e_10.error; }
        }
        this._cache.extraSchemas = tslib_1.__spread(allExtraSchemas);
        var directiveResolversToBeMerged = new Set(importsDirectiveResolvers);
        directiveResolversToBeMerged.add(this.selfDirectiveResolvers);
        this._cache.directiveResolvers = deepmerge.all(tslib_1.__spread(directiveResolversToBeMerged));
        try {
            if (typeDefsToBeMerged.size || allExtraSchemas.size) {
                var mergedTypeDefs = epoxy_1.mergeGraphQLSchemas(tslib_1.__spread(allExtraSchemas, typeDefsToBeMerged), {
                    useSchemaDefinition: false,
                });
                this._cache.typeDefs = mergedTypeDefs;
                var localSchema = graphql_tools_1.makeExecutableSchema({
                    typeDefs: mergedTypeDefs,
                    resolvers: composedResolvers,
                    schemaDirectives: mergedSchemaDirectives,
                    directiveResolvers: this._cache.directiveResolvers,
                    logger: this.selfLogger,
                    resolverValidationOptions: this.selfResolverValidationOptions,
                });
                if (allExtraSchemas.size) {
                    this._cache.schema = graphql_tools_1.mergeSchemas({
                        schemas: tslib_1.__spread([localSchema], allExtraSchemas),
                    });
                }
                else {
                    this._cache.schema = localSchema;
                }
                this.injector.provide({
                    provide: graphql_1.GraphQLSchema,
                    useValue: this._cache.schema,
                });
            }
        }
        catch (e) {
            if (e.message !== 'Must provide typeDefs') {
                if (e.message.includes("Type \"") && e.message.includes("\" not found in document.")) {
                    var typeDef = e.message.replace('Type "', '').replace('" not found in document.', '');
                    throw new errors_1.TypeDefNotFoundError(typeDef, this.name);
                }
                else {
                    throw new errors_1.SchemaNotValidError(this.name, e.message);
                }
            }
            else {
                this._cache.schema = null;
            }
        }
        this._cache.contextBuilder = function (session, excludeSession) {
            if (excludeSession === void 0) { excludeSession = false; }
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var moduleNameContextMap, importsContextArr$, importsContextArr, importsContext, applicationInjector, sessionInjector, moduleSessionInfo_1, moduleContext_1, moduleContextDeclaration, sessionHooks$, moduleContext, e_11;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 8, , 9]);
                            session = 'connection' in session ? session['connection']['context']['session'] : session;
                            moduleNameContextMap = this.getModuleNameContextMap(session);
                            if (!!(moduleNameContextMap.has(this.name))) return [3 /*break*/, 7];
                            importsContextArr$ = tslib_1.__spread(importsContextBuilders).map(function (contextBuilder) { return contextBuilder(session, true); });
                            return [4 /*yield*/, Promise.all(importsContextArr$)];
                        case 1:
                            importsContextArr = _a.sent();
                            importsContext = importsContextArr.reduce(function (acc, curr) { return (tslib_1.__assign({}, acc, curr)); }, {});
                            applicationInjector = this.injector;
                            sessionInjector = applicationInjector.getSessionInjector(session);
                            moduleSessionInfo_1 = sessionInjector.has(module_session_info_1.ModuleSessionInfo) ? sessionInjector.get(module_session_info_1.ModuleSessionInfo) : new module_session_info_1.ModuleSessionInfo(this, session);
                            moduleContext_1 = {};
                            moduleContextDeclaration = this._options.context;
                            if (!moduleContextDeclaration) return [3 /*break*/, 5];
                            if (!(moduleContextDeclaration instanceof Function)) return [3 /*break*/, 3];
                            return [4 /*yield*/, moduleContextDeclaration(session, tslib_1.__assign({}, importsContext, { injector: injector }), moduleSessionInfo_1)];
                        case 2:
                            moduleContext_1 = _a.sent();
                            return [3 /*break*/, 5];
                        case 3: return [4 /*yield*/, moduleContextDeclaration];
                        case 4:
                            moduleContext_1 = _a.sent();
                            _a.label = 5;
                        case 5:
                            moduleNameContextMap.set(this.name, tslib_1.__assign({}, importsContext, moduleContext_1, { injector: sessionInjector }));
                            sessionHooks$ = tslib_1.__spread(applicationInjector.scopeSet, sessionInjector.scopeSet).map(function (serviceIdentifier) { return moduleSessionInfo_1.callSessionHook(serviceIdentifier); });
                            return [4 /*yield*/, Promise.all(sessionHooks$)];
                        case 6:
                            _a.sent();
                            _a.label = 7;
                        case 7:
                            moduleContext = moduleNameContextMap.get(this.name);
                            if (excludeSession) {
                                return [2 /*return*/, moduleContext];
                            }
                            else {
                                return [2 /*return*/, tslib_1.__assign({}, moduleContext, { session: session })];
                            }
                            return [3 /*break*/, 9];
                        case 8:
                            e_11 = _a.sent();
                            if (e_11 instanceof errors_1.ContextBuilderError) {
                                throw e_11;
                            }
                            else {
                                throw new errors_1.ContextBuilderError(this.name, e_11);
                            }
                            return [3 /*break*/, 9];
                        case 9: return [2 /*return*/];
                    }
                });
            });
        };
        this._cache.subscriptionHooks = {
            onConnect: function (connectionParams, websocket, connectionSession) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var importsOnConnectHooks$, importsOnConnectHooks, importsResult, connectionContext, applicationInjector, sessionInjector, sessionHooks$, results, hookResult, finalResult, moduleNameContextMap;
                var _this = this;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            importsOnConnectHooks$ = tslib_1.__spread(importsSubscriptionHooks).map(function (_a) {
                                var onConnect = _a.onConnect;
                                return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_b) {
                                    return [2 /*return*/, onConnect && onConnect(connectionParams, websocket, connectionSession)];
                                }); });
                            });
                            return [4 /*yield*/, Promise.all(importsOnConnectHooks$)];
                        case 1:
                            importsOnConnectHooks = _a.sent();
                            importsResult = importsOnConnectHooks.reduce(function (acc, curr) { return (tslib_1.__assign({}, acc, (curr || {}))); }, {});
                            return [4 /*yield*/, this.context(connectionSession)];
                        case 2:
                            connectionContext = _a.sent();
                            applicationInjector = this.injector;
                            sessionInjector = connectionContext.injector;
                            sessionHooks$ = tslib_1.__spread(applicationInjector.scopeSet, sessionInjector.scopeSet).map(function (serviceIdentifier) { return sessionInjector.callHookWithArgs('onConnect', serviceIdentifier, connectionParams, websocket, connectionContext); });
                            return [4 /*yield*/, Promise.all(sessionHooks$)];
                        case 3:
                            results = _a.sent();
                            hookResult = results.reduce(function (acc, curr) { return (tslib_1.__assign({}, acc, (curr || {}))); }, {});
                            finalResult = tslib_1.__assign({}, importsResult, connectionContext, hookResult);
                            moduleNameContextMap = this.getModuleNameContextMap(connectionSession);
                            moduleNameContextMap.set(this.name, finalResult);
                            return [2 /*return*/, finalResult];
                    }
                });
            }); },
            onDisconnect: function (websocket, connectionSession) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var importsOnConnectHooks$, importsOnConnectHooks, importsResult, connectionContext, applicationInjector, sessionInjector, sessionHooks$, results, hookResult, finalResult, moduleNameContextMap;
                var _this = this;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            importsOnConnectHooks$ = tslib_1.__spread(importsSubscriptionHooks).map(function (_a) {
                                var onDisconnect = _a.onDisconnect;
                                return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_b) {
                                    return [2 /*return*/, onDisconnect && onDisconnect(websocket, connectionSession)];
                                }); });
                            });
                            return [4 /*yield*/, Promise.all(importsOnConnectHooks$)];
                        case 1:
                            importsOnConnectHooks = _a.sent();
                            importsResult = importsOnConnectHooks.reduce(function (acc, curr) { return (tslib_1.__assign({}, acc, (curr || {}))); }, {});
                            return [4 /*yield*/, this.context(connectionSession)];
                        case 2:
                            connectionContext = _a.sent();
                            applicationInjector = this.injector;
                            sessionInjector = connectionContext.injector;
                            sessionHooks$ = tslib_1.__spread(applicationInjector.scopeSet, sessionInjector.scopeSet).map(function (serviceIdentifier) { return sessionInjector.callHookWithArgs('onDisconnect', serviceIdentifier, websocket, connectionContext); });
                            return [4 /*yield*/, Promise.all(sessionHooks$)];
                        case 3:
                            results = _a.sent();
                            hookResult = results.reduce(function (acc, curr) { return (tslib_1.__assign({}, acc, (curr || {}))); }, {});
                            finalResult = tslib_1.__assign({}, importsResult, connectionContext, hookResult);
                            moduleNameContextMap = this.getModuleNameContextMap(connectionSession);
                            moduleNameContextMap.set(this.name, finalResult);
                            return [2 /*return*/, finalResult];
                    }
                });
            }); },
        };
        if ('middleware' in this._options) {
            var middlewareResult = this._options.middleware(this._cache);
            this._cache = Object.assign(this._cache, middlewareResult);
        }
    };
    GraphQLModule.prototype.getModuleNameContextMap = function (session) {
        if (!GraphQLModule.sessionModuleNameContextMap.has(session)) {
            GraphQLModule.sessionModuleNameContextMap.set(session, new Map());
        }
        return GraphQLModule.sessionModuleNameContextMap.get(session);
    };
    Object.defineProperty(GraphQLModule.prototype, "context", {
        /**
         * Build a GraphQL `context` object based on a network session.
         * It iterates over all modules by their dependency-based order, and executes
         * `contextBuilder` method.
         * It also in charge of injecting a reference to the application `Injector` to
         * the `context`.
         * The network session is passed to each `contextBuilder` method, and the return
         * value of each `contextBuilder` is merged into a unified `context` object.
         *
         * This method should be in use with your GraphQL manager, such as Apollo-Server.
         *
         * @param session - the network session from `connect`, `express`, etc...
         */
        get: function () {
            if (!this._cache.contextBuilder) {
                this.buildSchemaAndInjector();
            }
            return this._cache.contextBuilder.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphQLModule.prototype, "modulesMap", {
        get: function () {
            if (!this._cache.modulesMap) {
                var modulesMap = this.createInitialModulesMap();
                modulesMap = this.checkAndFixModulesMap(modulesMap);
                this._cache.modulesMap = modulesMap;
            }
            return this._cache.modulesMap;
        },
        enumerable: true,
        configurable: true
    });
    GraphQLModule.prototype.createInitialModulesMap = function () {
        var modulesMap = new Map();
        var visitModule = function (module) {
            var e_12, _a;
            if (!modulesMap.has(module.name)) {
                modulesMap.set(module.name, module);
                try {
                    for (var _b = tslib_1.__values(module.selfImports), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subModule = _c.value;
                        if (!subModule) {
                            throw new errors_1.DependencyModuleUndefinedError(module.name);
                        }
                        if (typeof subModule !== 'string') {
                            if (subModule._options.configRequired) {
                                if (subModule.config) {
                                    visitModule(subModule);
                                }
                            }
                            else {
                                visitModule(subModule);
                            }
                        }
                    }
                }
                catch (e_12_1) { e_12 = { error: e_12_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_12) throw e_12.error; }
                }
            }
        };
        visitModule(this);
        return modulesMap;
    };
    GraphQLModule.prototype.checkAndFixModulesMap = function (modulesMap) {
        var e_13, _a, e_14, _b;
        var graph = new dependency_graph_1.DepGraph();
        modulesMap.forEach(function (module) {
            var moduleName = module.name;
            if (!graph.hasNode(moduleName)) {
                graph.addNode(moduleName);
            }
        });
        var visitedModulesToAddDependency = new Set();
        var visitModuleToAddDependency = function (module) {
            var e_15, _a;
            try {
                for (var _b = tslib_1.__values(module.selfImports), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var subModule = _c.value;
                    var subModuleOrigName = typeof subModule === 'string' ? subModule : subModule.name;
                    subModule = modulesMap.get(subModuleOrigName);
                    if (!subModule) {
                        throw new errors_1.DependencyModuleNotFoundError(subModuleOrigName, module.name);
                    }
                    try {
                        graph.addDependency(module.name, subModule.name);
                    }
                    catch (e) {
                        throw new errors_1.DependencyModuleNotFoundError(subModuleOrigName, module.name);
                    }
                    // prevent infinite loop in case of circular dependency
                    if (!visitedModulesToAddDependency.has(subModule.name)) {
                        visitedModulesToAddDependency.add(subModule.name);
                        visitModuleToAddDependency(subModule);
                    }
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_15) throw e_15.error; }
            }
        };
        visitModuleToAddDependency(modulesMap.get(this.name));
        try {
            graph.overallOrder();
            return modulesMap;
        }
        catch (e) {
            var message = e.message;
            var currentPathStr = message.replace('Dependency Cycle Found: ', '');
            if (!this._options.mergeCircularImports) {
                throw e;
            }
            if (this._options.warnCircularImports) {
                this.selfLogger.log(e.message);
            }
            var currentPath = currentPathStr.split(' -> ');
            var moduleIndexMap_1 = new Map();
            var start_1 = 0;
            var end_1 = currentPath.length;
            currentPath.forEach(function (moduleName, index) {
                if (moduleIndexMap_1.has(moduleName)) {
                    start_1 = moduleIndexMap_1.get(moduleName);
                    end_1 = index;
                }
                else {
                    moduleIndexMap_1.set(moduleName, index);
                }
            });
            var realPath = currentPath.slice(start_1, end_1);
            var circularModules = Array.from(new Set(realPath)).map(function (moduleName) {
                // if it is merged module, get one module, it will be enough to get merged one.
                return modulesMap.get(moduleName);
            });
            var mergedModule_1 = GraphQLModule.mergeModules(circularModules, this._options.warnCircularImports, modulesMap);
            try {
                for (var realPath_1 = tslib_1.__values(realPath), realPath_1_1 = realPath_1.next(); !realPath_1_1.done; realPath_1_1 = realPath_1.next()) {
                    var moduleName = realPath_1_1.value;
                    modulesMap.set(moduleName, mergedModule_1);
                    try {
                        for (var _c = tslib_1.__values(moduleName.split('+')), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var subModuleName = _d.value;
                            if (modulesMap.has(subModuleName)) {
                                modulesMap.set(subModuleName, mergedModule_1);
                            }
                        }
                    }
                    catch (e_14_1) { e_14 = { error: e_14_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                        }
                        finally { if (e_14) throw e_14.error; }
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (realPath_1_1 && !realPath_1_1.done && (_a = realPath_1.return)) _a.call(realPath_1);
                }
                finally { if (e_13) throw e_13.error; }
            }
            modulesMap.set(mergedModule_1.name, mergedModule_1);
            mergedModule_1._options.imports
                = mergedModule_1._options.imports.filter(function (module) {
                    var moduleName = typeof module === 'string' ? module : module.name;
                    module = modulesMap.get(moduleName);
                    return (module.name !== mergedModule_1.name);
                });
            return this.checkAndFixModulesMap(modulesMap);
        }
    };
    GraphQLModule.mergeModules = function (modules, warnCircularImports, modulesMap) {
        var _this = this;
        if (warnCircularImports === void 0) { warnCircularImports = false; }
        var e_16, _a, e_17, _b, e_18, _c, e_19, _d, e_20, _e;
        var nameSet = new Set();
        var typeDefsSet = new Set();
        var resolversSet = new Set();
        var contextBuilderSet = new Set();
        var importsSet = new Set();
        var providersSet = new Set();
        var resolversCompositionSet = new Set();
        var schemaDirectivesSet = new Set();
        var directiveResolversSet = new Set();
        var loggerSet = new Set();
        var extraSchemasSet = new Set();
        var middlewareSet = new Set();
        try {
            for (var modules_1 = tslib_1.__values(modules), modules_1_1 = modules_1.next(); !modules_1_1.done; modules_1_1 = modules_1.next()) {
                var module_3 = modules_1_1.value;
                var subMergedModuleNames = module_3.name.split('+');
                try {
                    for (var subMergedModuleNames_1 = tslib_1.__values(subMergedModuleNames), subMergedModuleNames_1_1 = subMergedModuleNames_1.next(); !subMergedModuleNames_1_1.done; subMergedModuleNames_1_1 = subMergedModuleNames_1.next()) {
                        var subMergedModuleName = subMergedModuleNames_1_1.value;
                        nameSet.add(subMergedModuleName);
                    }
                }
                catch (e_17_1) { e_17 = { error: e_17_1 }; }
                finally {
                    try {
                        if (subMergedModuleNames_1_1 && !subMergedModuleNames_1_1.done && (_b = subMergedModuleNames_1.return)) _b.call(subMergedModuleNames_1);
                    }
                    finally { if (e_17) throw e_17.error; }
                }
                var typeDefs_1 = module_3.selfTypeDefs;
                if (typeDefs_1) {
                    typeDefsSet.add(typeDefs_1);
                }
                resolversSet.add(module_3.selfResolvers);
                contextBuilderSet.add(module_3._options.context);
                try {
                    for (var _f = tslib_1.__values(module_3.selfImports), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var importModule = _g.value;
                        if (modulesMap) {
                            importModule = modulesMap.get(typeof importModule === 'string' ? importModule : importModule.name);
                        }
                        importsSet.add(importModule);
                    }
                }
                catch (e_18_1) { e_18 = { error: e_18_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                    }
                    finally { if (e_18) throw e_18.error; }
                }
                try {
                    for (var _h = tslib_1.__values(module_3.selfProviders), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var provider = _j.value;
                        providersSet.add(provider);
                    }
                }
                catch (e_19_1) { e_19 = { error: e_19_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_d = _h.return)) _d.call(_h);
                    }
                    finally { if (e_19) throw e_19.error; }
                }
                resolversCompositionSet.add(module_3.selfResolversComposition);
                schemaDirectivesSet.add(module_3.selfSchemaDirectives);
                directiveResolversSet.add(module_3.selfDirectiveResolvers);
                try {
                    for (var _k = tslib_1.__values(module_3.selfExtraSchemas), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var extraSchema = _l.value;
                        extraSchemasSet.add(extraSchema);
                    }
                }
                catch (e_20_1) { e_20 = { error: e_20_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_e = _k.return)) _e.call(_k);
                    }
                    finally { if (e_20) throw e_20.error; }
                }
                loggerSet.add(module_3.selfLogger);
            }
        }
        catch (e_16_1) { e_16 = { error: e_16_1 }; }
        finally {
            try {
                if (modules_1_1 && !modules_1_1.done && (_a = modules_1.return)) _a.call(modules_1);
            }
            finally { if (e_16) throw e_16.error; }
        }
        var name = tslib_1.__spread(nameSet).join('+');
        var typeDefs = tslib_1.__spread(typeDefsSet);
        var resolvers = epoxy_1.mergeResolvers(tslib_1.__spread(resolversSet));
        var context = tslib_1.__spread(contextBuilderSet).reduce(function (accContextBuilder, currentContextBuilder) {
            return function (session, currentContext, injector) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var accContext, moduleContext, _a;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, accContextBuilder(session, currentContext, injector)];
                        case 1:
                            accContext = _b.sent();
                            if (!(typeof currentContextBuilder === 'function')) return [3 /*break*/, 3];
                            return [4 /*yield*/, currentContextBuilder(session, currentContext, injector)];
                        case 2:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            _a = (currentContextBuilder || {});
                            _b.label = 4;
                        case 4:
                            moduleContext = _a;
                            return [2 /*return*/, tslib_1.__assign({}, accContext, moduleContext)];
                    }
                });
            }); };
        }, function () { return ({}); });
        var imports = tslib_1.__spread(importsSet);
        var providers = tslib_1.__spread(providersSet);
        var resolversComposition = deepmerge.all(tslib_1.__spread(resolversCompositionSet));
        var schemaDirectives = deepmerge.all(tslib_1.__spread(schemaDirectivesSet));
        var directiveResolvers = deepmerge.all(tslib_1.__spread(directiveResolversSet));
        var logger = {
            log: function (message) {
                var e_21, _a;
                try {
                    for (var loggerSet_1 = tslib_1.__values(loggerSet), loggerSet_1_1 = loggerSet_1.next(); !loggerSet_1_1.done; loggerSet_1_1 = loggerSet_1.next()) {
                        var logger_1 = loggerSet_1_1.value;
                        logger_1.log(message);
                    }
                }
                catch (e_21_1) { e_21 = { error: e_21_1 }; }
                finally {
                    try {
                        if (loggerSet_1_1 && !loggerSet_1_1.done && (_a = loggerSet_1.return)) _a.call(loggerSet_1);
                    }
                    finally { if (e_21) throw e_21.error; }
                }
            },
        };
        var extraSchemas = tslib_1.__spread(extraSchemasSet);
        var middleware = function (moduleCache) {
            var e_22, _a;
            var result = {};
            try {
                for (var middlewareSet_1 = tslib_1.__values(middlewareSet), middlewareSet_1_1 = middlewareSet_1.next(); !middlewareSet_1_1.done; middlewareSet_1_1 = middlewareSet_1.next()) {
                    var subMiddleware = middlewareSet_1_1.value;
                    result = Object.assign(result, subMiddleware(moduleCache));
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (middlewareSet_1_1 && !middlewareSet_1_1.done && (_a = middlewareSet_1.return)) _a.call(middlewareSet_1);
                }
                finally { if (e_22) throw e_22.error; }
            }
            return result;
        };
        return new GraphQLModule({
            name: name,
            typeDefs: typeDefs,
            resolvers: resolvers,
            context: context,
            imports: imports,
            providers: providers,
            resolversComposition: resolversComposition,
            schemaDirectives: schemaDirectives,
            directiveResolvers: directiveResolvers,
            logger: logger,
            extraSchemas: extraSchemas,
            middleware: middleware,
            warnCircularImports: warnCircularImports,
            mergeCircularImports: true,
        });
    };
    GraphQLModule.sessionModuleNameContextMap = new WeakMap();
    return GraphQLModule;
}());
exports.GraphQLModule = GraphQLModule;
//# sourceMappingURL=graphql-module.js.map