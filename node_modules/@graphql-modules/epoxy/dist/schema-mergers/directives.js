"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
function directiveAlreadyExists(directivesArr, otherDirective) {
    return !!directivesArr.find(function (directive) { return directive.name.value === otherDirective.name.value; });
}
function nameAlreadyExists(name, namesArr) {
    return namesArr.some(function (_a) {
        var value = _a.value;
        return value === name.value;
    });
}
function mergeArguments(a1, a2) {
    var e_1, _a;
    var result = tslib_1.__spread(a2);
    var _loop_1 = function (argument) {
        var existingIndex = result.findIndex(function (a) { return a.name.value === argument.name.value; });
        if (existingIndex > -1) {
            var existingArg = result[existingIndex];
            if (existingArg.value.kind === 'ListValue') {
                existingArg.value.values = tslib_1.__spread(existingArg.value.values, argument.value.values);
            }
            else {
                existingArg.value = argument.value;
            }
        }
        else {
            result.push(argument);
        }
    };
    try {
        for (var a1_1 = tslib_1.__values(a1), a1_1_1 = a1_1.next(); !a1_1_1.done; a1_1_1 = a1_1.next()) {
            var argument = a1_1_1.value;
            _loop_1(argument);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (a1_1_1 && !a1_1_1.done && (_a = a1_1.return)) _a.call(a1_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
function mergeDirectives(d1, d2) {
    var e_2, _a;
    var result = tslib_1.__spread(d2);
    var _loop_2 = function (directive) {
        if (directiveAlreadyExists(result, directive)) {
            var existingDirectiveIndex = result.findIndex(function (d) { return d.name.value === directive.name.value; });
            var existingDirective = result[existingDirectiveIndex];
            result[existingDirectiveIndex].arguments = mergeArguments(existingDirective.arguments, directive.arguments);
        }
        else {
            result.push(directive);
        }
    };
    try {
        for (var d1_1 = tslib_1.__values(d1), d1_1_1 = d1_1.next(); !d1_1_1.done; d1_1_1 = d1_1.next()) {
            var directive = d1_1_1.value;
            _loop_2(directive);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (d1_1_1 && !d1_1_1.done && (_a = d1_1.return)) _a.call(d1_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return result;
}
exports.mergeDirectives = mergeDirectives;
function validateInputs(node, existingNode) {
    var printedNode = graphql_1.print(node);
    var printedExistingNode = graphql_1.print(existingNode);
    var leaveInputs = new RegExp('(directive @\w*\d*)|( on .*$)', 'g');
    var sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');
    if (!sameArguments) {
        throw new Error("Unable to merge GraphQL directive \"" + node.name.value + "\". \nExisting directive:  \n\t" + printedExistingNode + " \nReceived directive: \n\t" + printedNode);
    }
}
function mergeDirective(node, existingNode) {
    if (existingNode) {
        validateInputs(node, existingNode);
        return tslib_1.__assign({}, node, { locations: tslib_1.__spread(existingNode.locations, (node.locations.filter(function (name) { return !nameAlreadyExists(name, existingNode.locations); }))) });
    }
    return node;
}
exports.mergeDirective = mergeDirective;
//# sourceMappingURL=directives.js.map